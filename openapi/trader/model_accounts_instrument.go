/*
Trader API - Account Access and User Preferences

Schwab Trader API access to Account, Order entry and User Preferences

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package trader

import (
	"encoding/json"
	"fmt"
)

// AccountsInstrument - struct for AccountsInstrument
type AccountsInstrument struct {
	AccountCashEquivalent *AccountCashEquivalent
	AccountEquity *AccountEquity
	AccountFixedIncome *AccountFixedIncome
	AccountMutualFund *AccountMutualFund
	AccountOption *AccountOption
}

// AccountCashEquivalentAsAccountsInstrument is a convenience function that returns AccountCashEquivalent wrapped in AccountsInstrument
func AccountCashEquivalentAsAccountsInstrument(v *AccountCashEquivalent) AccountsInstrument {
	return AccountsInstrument{
		AccountCashEquivalent: v,
	}
}

// AccountEquityAsAccountsInstrument is a convenience function that returns AccountEquity wrapped in AccountsInstrument
func AccountEquityAsAccountsInstrument(v *AccountEquity) AccountsInstrument {
	return AccountsInstrument{
		AccountEquity: v,
	}
}

// AccountFixedIncomeAsAccountsInstrument is a convenience function that returns AccountFixedIncome wrapped in AccountsInstrument
func AccountFixedIncomeAsAccountsInstrument(v *AccountFixedIncome) AccountsInstrument {
	return AccountsInstrument{
		AccountFixedIncome: v,
	}
}

// AccountMutualFundAsAccountsInstrument is a convenience function that returns AccountMutualFund wrapped in AccountsInstrument
func AccountMutualFundAsAccountsInstrument(v *AccountMutualFund) AccountsInstrument {
	return AccountsInstrument{
		AccountMutualFund: v,
	}
}

// AccountOptionAsAccountsInstrument is a convenience function that returns AccountOption wrapped in AccountsInstrument
func AccountOptionAsAccountsInstrument(v *AccountOption) AccountsInstrument {
	return AccountsInstrument{
		AccountOption: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *AccountsInstrument) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into AccountCashEquivalent
	err = newStrictDecoder(data).Decode(&dst.AccountCashEquivalent)
	if err == nil {
		jsonAccountCashEquivalent, _ := json.Marshal(dst.AccountCashEquivalent)
		if string(jsonAccountCashEquivalent) == "{}" { // empty struct
			dst.AccountCashEquivalent = nil
		} else {
			match++
		}
	} else {
		dst.AccountCashEquivalent = nil
	}

	// try to unmarshal data into AccountEquity
	err = newStrictDecoder(data).Decode(&dst.AccountEquity)
	if err == nil {
		jsonAccountEquity, _ := json.Marshal(dst.AccountEquity)
		if string(jsonAccountEquity) == "{}" { // empty struct
			dst.AccountEquity = nil
		} else {
			match++
		}
	} else {
		dst.AccountEquity = nil
	}

	// try to unmarshal data into AccountFixedIncome
	err = newStrictDecoder(data).Decode(&dst.AccountFixedIncome)
	if err == nil {
		jsonAccountFixedIncome, _ := json.Marshal(dst.AccountFixedIncome)
		if string(jsonAccountFixedIncome) == "{}" { // empty struct
			dst.AccountFixedIncome = nil
		} else {
			match++
		}
	} else {
		dst.AccountFixedIncome = nil
	}

	// try to unmarshal data into AccountMutualFund
	err = newStrictDecoder(data).Decode(&dst.AccountMutualFund)
	if err == nil {
		jsonAccountMutualFund, _ := json.Marshal(dst.AccountMutualFund)
		if string(jsonAccountMutualFund) == "{}" { // empty struct
			dst.AccountMutualFund = nil
		} else {
			match++
		}
	} else {
		dst.AccountMutualFund = nil
	}

	// try to unmarshal data into AccountOption
	err = newStrictDecoder(data).Decode(&dst.AccountOption)
	if err == nil {
		jsonAccountOption, _ := json.Marshal(dst.AccountOption)
		if string(jsonAccountOption) == "{}" { // empty struct
			dst.AccountOption = nil
		} else {
			match++
		}
	} else {
		dst.AccountOption = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.AccountCashEquivalent = nil
		dst.AccountEquity = nil
		dst.AccountFixedIncome = nil
		dst.AccountMutualFund = nil
		dst.AccountOption = nil

		return fmt.Errorf("data matches more than one schema in oneOf(AccountsInstrument)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(AccountsInstrument)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src AccountsInstrument) MarshalJSON() ([]byte, error) {
	if src.AccountCashEquivalent != nil {
		return json.Marshal(&src.AccountCashEquivalent)
	}

	if src.AccountEquity != nil {
		return json.Marshal(&src.AccountEquity)
	}

	if src.AccountFixedIncome != nil {
		return json.Marshal(&src.AccountFixedIncome)
	}

	if src.AccountMutualFund != nil {
		return json.Marshal(&src.AccountMutualFund)
	}

	if src.AccountOption != nil {
		return json.Marshal(&src.AccountOption)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *AccountsInstrument) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.AccountCashEquivalent != nil {
		return obj.AccountCashEquivalent
	}

	if obj.AccountEquity != nil {
		return obj.AccountEquity
	}

	if obj.AccountFixedIncome != nil {
		return obj.AccountFixedIncome
	}

	if obj.AccountMutualFund != nil {
		return obj.AccountMutualFund
	}

	if obj.AccountOption != nil {
		return obj.AccountOption
	}

	// all schemas are nil
	return nil
}

type NullableAccountsInstrument struct {
	value *AccountsInstrument
	isSet bool
}

func (v NullableAccountsInstrument) Get() *AccountsInstrument {
	return v.value
}

func (v *NullableAccountsInstrument) Set(val *AccountsInstrument) {
	v.value = val
	v.isSet = true
}

func (v NullableAccountsInstrument) IsSet() bool {
	return v.isSet
}

func (v *NullableAccountsInstrument) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAccountsInstrument(val *AccountsInstrument) *NullableAccountsInstrument {
	return &NullableAccountsInstrument{value: val, isSet: true}
}

func (v NullableAccountsInstrument) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAccountsInstrument) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


